import sqlite3
import traceback
# This file was generated by the Tkinter Designer by Parth Jadhav
# https://github.com/ParthJadhav/Tkinter-Designer


from pathlib import Path

# from tkinter import *
# Explicit imports to satisfy Flake8
from tkinter import Tk, Canvas, Entry, Text, Button, PhotoImage, Frame

from tkinter import Frame, Canvas, Label, Entry, Button, PhotoImage, messagebox, Toplevel, filedialog, ttk
import os
from tkinter.ttk import Treeview, Scrollbar

import PIL
from PIL import Image, ImageTk

import user_session
from database import (
    get_all_pizzas,
    get_pizza_by_id,
    add_pizza,
    update_pizza,
    delete_pizza,
    search_pizzas_by_name, conn,
)



class Menu(Frame):
    def __init__(self, parent, controller=None, *args, **kwargs):
        Frame.__init__(self, parent, *args, **kwargs)

        self.parent = parent
        self.controller = controller

        self.configure(bg="#CEAB83")

        # Кэш для изображений
        self.image_cache = {}
        # self.access_level = user_session.session.get_access_level()
        self.access_level = 1
        print(f"Уровень доступа: {self.access_level}")

        # Создаём интерфейс
        self.create_widgets()
        self.load_menu()
        self.tree.update()
        style1 = ttk.Style()
        style1.configure('mystyle.Treeview', rowheight=100, font=('Montserrat Alternates', 13))
        style1.configure('mystyle.Treeview.Heading',
                         background='#715E48',
                         font=('Montserrat Alternates Bold', 15),
                         foreground='black')
        style1.configure('mystyle.Treeview.Cell', wraplength=340)
        btn_style = ttk.Style()
        btn_style.configure('my.TButton', font=('Montserrat Alternates Bold', 10),
                            background='#CEAB83', foreground='black')




    def create_widgets(self):
        """Создаёт элементы интерфейса."""
        # Canvas для заголовка и рамки
        self.canvas = Canvas(
            self,
            bg="#CEAB83",
            height=700,
            width=948,
            bd=0,
            highlightthickness=0,
            relief="ridge"
        )
        self.canvas.place(x=0, y=0)
        self.canvas.create_text(
            23.0,
            27.0,
            anchor="nw",
            text="Меню",
            fill="#000000",
            font=("Montserrat Alternates Bold", 36 * -1)
        )

        # Поле для поиска
        Label(self, text="Поиск:", bg="#CEAB83", font=("Montserrat Alternates", 13)).place(x=45, y=85)
        self.search_entry = ttk.Entry(self)
        self.search_entry.place(x=110, y=90, width=200)
        ttk.Button(self, text="Найти", command=self.search_pizzas, style='my.TButton').place(x=320, y=88)

        # Таблица для отображения меню

        self.tree = Treeview(self, show="tree headings", style="mystyle.Treeview")
        self.tree["columns"] = ("name", "description", "price", "weight")
        self.tree["selectmode"] = "browse"
        self.tree.heading("name", text="Название")
        self.tree.heading("description", text="Описание")
        self.tree.heading("price", text="Цена (₽)")
        self.tree.heading("weight", text="Вес (г)")
        self.tree.heading("#0", text="Фото")
        self.tree.column("name", width=180, anchor="center")
        self.tree.column("description", width=340, anchor="n")
        self.tree.column("price", width=100, anchor="center")
        self.tree.column("weight", width=100, anchor="center")
        self.tree.column("#0", width=130, anchor="center")
        self.tree.configure(height=50)
        self.tree.place(x=50, y=130, width=850, height=520)

        # Прокрутка для таблицы
        scrollbar = Scrollbar(self, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscroll=scrollbar.set)
        scrollbar.place(x=900, y=130, height=520)

        # Кнопки управления
        if self.access_level == 1:
            ttk.Button(self, text="Добавить пиццу", command=self.open_add_pizza_window, style='my.TButton').place(x=50, y=650, width=150, height=30)
            ttk.Button(self, text="Редактировать пиццу", command=self.open_edit_pizza_window, style='my.TButton').place(x=210, y=650, width=200, height=30)
            ttk.Button(self, text="Удалить пиццу", command=self.delete_pizza, style='my.TButton').place(x=420, y=650, width=150, height=30)

        # Привязка события для отображения изображения
        # self.tree.bind("<<TreeviewSelect>>", self.show_image)

    def load_menu(self, pizzas=None):
        """Загружает данные меню из базы и отображает их в таблице."""
        for row in self.tree.get_children():
            self.tree.delete(row)

        if pizzas is None:
            pizzas = get_all_pizzas(conn)  # Загрузка всех пицц через функции базы данных

        self.image_cache = {}
        for row in pizzas:
            pizza_id, name, description, price, weight, image_path = row
            img_tk = self.get_image(pizza_id, image_path)
            if img_tk:
                self.tree.insert("", "end", image=img_tk, values=(name, description, f"{price:.2f}", weight))
            else:
                self.tree.insert("", "end", values=(name, description, f"{price:.2f}", weight))

        self.tree.update()

    def get_image(self, pizza_id, image_path):
        if pizza_id in self.image_cache:
            return self.image_cache[pizza_id]

        abs_path = os.path.abspath(image_path)
        # print(f"Полный путь к файлу: {abs_path}")
        if os.path.exists(str(image_path)):
            try:
                img = Image.open(abs_path).resize((100, 100), Image.LANCZOS)
                img_tk = ImageTk.PhotoImage(img)
                self.image_cache[pizza_id] = img_tk
                return img_tk
            except FileNotFoundError:
                print(f"Файл изображения не найден: {abs_path}")
            except IOError as e:
                print(f"Ошибка чтения файла изображения: {abs_path}, {e}")
            except Exception as e:
                print(f"Непредвиденная ошибка при загрузке изображения: {abs_path}, {e}")
                traceback.print_exc()
        else:
            print(f"Файл изображения не существует: {abs_path}")
        return None



    def search_pizzas(self):
        """Ищет пиццы по названию."""
        search_term = self.search_entry.get().strip()
        if not search_term:
            self.load_menu()
            return

        try:
            pizzas = search_pizzas_by_name(conn, search_term)
            self.load_menu(pizzas)
        except Exception as e:
            messagebox.showerror("Ошибка", f"Не удалось выполнить поиск: {e}")

    def open_add_pizza_window(self):
        AddOrEditPizzaWindow(conn, self.load_menu)

    def open_edit_pizza_window(self):
        selected = self.tree.selection()
        if not selected:
            messagebox.showerror("Ошибка", "Выберите пиццу для редактирования.")
            return

        item_index = self.tree.index(selected[0])
        pizza_id = list(self.image_cache.keys())[item_index]
        AddOrEditPizzaWindow(conn, self.load_menu, pizza_id)

    def delete_pizza(self):
        """Удаляет выбранную пиццу."""
        selected = self.tree.selection()
        if not selected:
            messagebox.showerror("Ошибка", "Выберите пиццу для удаления.")
            return

        item_index = self.tree.index(selected[0])
        pizza_id = list(self.image_cache.keys())[item_index]

        confirm = messagebox.askyesno("Удаление", f"Вы уверены, что хотите удалить пиццу ID {pizza_id}?")
        if not confirm:
            return

        try:
            delete_pizza(self.controller.conn, pizza_id)
            messagebox.showinfo("Успех", "Пицца успешно удалена!")
            self.load_menu()
        except sqlite3.Error as e:
            messagebox.showerror("Ошибка", f"Не удалось удалить пиццу: {e}")


class AddOrEditPizzaWindow(Toplevel):
    """
    Окно для добавления или редактирования пиццы.
    """
    def __init__(self, conn, refresh_callback, pizza_id=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.conn = conn
        self.refresh_callback = refresh_callback
        self.pizza_id = pizza_id
        self.title("Редактировать пиццу" if pizza_id else "Добавить пиццу")
        self.geometry("400x400")
        self.configure(bg="#FFFFFF")

        # Поля для данных пиццы
        ttk.Label(self, text="Название:").grid(row=0, column=0, pady=5, padx=5, sticky="e")
        self.name_entry = ttk.Entry(self)
        self.name_entry.grid(row=0, column=1, pady=5, padx=5)

        ttk.Label(self, text="Описание:").grid(row=1, column=0, pady=5, padx=5, sticky="e")
        self.description_entry = ttk.Entry(self)
        self.description_entry.grid(row=1, column=1, pady=5, padx=5)

        ttk.Label(self, text="Цена (₽):").grid(row=2, column=0, pady=5, padx=5, sticky="e")
        self.price_entry = ttk.Entry(self)
        self.price_entry.grid(row=2, column=1, pady=5, padx=5)

        ttk.Label(self, text="Вес (г):").grid(row=3, column=0, pady=5, padx=5, sticky="e")
        self.weight_entry = ttk.Entry(self)
        self.weight_entry.grid(row=3, column=1, pady=5, padx=5)

        ttk.Label(self, text="Изображение:").grid(row=4, column=0, pady=5, padx=5, sticky="e")
        self.image_path_entry = ttk.Entry(self)
        self.image_path_entry.grid(row=4, column=1, pady=5, padx=5)
        ttk.Button(self, text="Выбрать файл", command=self.select_image).grid(row=4, column=2, padx=5)

        # Кнопка сохранения
        ttk.Button(self, text="Сохранить", command=self.save_pizza).grid(row=5, column=0, columnspan=3, pady=20)

        if pizza_id:
            self.load_pizza_data()

    def load_pizza_data(self):
        """Загружает данные пиццы для редактирования."""
        cursor = self.conn.cursor()
        cursor.execute("SELECT name, description, price, weight, image_path FROM pizzas WHERE pizza_id = ?", (self.pizza_id,))
        pizza = cursor.fetchone()
        if pizza:
            self.name_entry.insert(0, pizza[0])
            self.description_entry.insert(0, pizza[1])
            self.price_entry.insert(0, pizza[2])
            self.weight_entry.insert(0, pizza[3])
            self.image_path_entry.insert(0, pizza[4])

    def select_image(self):
        """Выбирает файл изображения."""
        file_path = filedialog.askopenfilename(filetypes=[("PNG files", "*.png"), ("JPEG files", "*.jpg"), ("All files", "*.*")])
        if file_path:
            self.image_path_entry.delete(0, "end")
            self.image_path_entry.insert(0, file_path)

    def save_pizza(self):
        """Сохраняет данные пиццы в базу."""
        name = self.name_entry.get().strip()
        description = self.description_entry.get().strip()
        price = self.price_entry.get().strip()
        weight = self.weight_entry.get().strip()
        image_path = self.image_path_entry.get().strip()

        if not name or not description or not price or not weight:
            messagebox.showerror("Ошибка", "Все поля, кроме изображения, обязательны!")
            return

        cursor = self.conn.cursor()
        try:
            if self.pizza_id:
                cursor.execute("""
                    UPDATE pizzas
                    SET name = ?, description = ?, price = ?, weight = ?, image_path = ?
                    WHERE pizza_id = ?
                """, (name, description, price, weight, image_path, self.pizza_id))
            else:
                cursor.execute("""
                    INSERT INTO pizzas (name, description, price, weight, image_path)
                    VALUES (?, ?, ?, ?, ?)
                """, (name, description, price, weight, image_path))
            self.conn.commit()
            messagebox.showinfo("Успех", "Пицца успешно сохранена!")
            self.refresh_callback()
            self.destroy()
        except sqlite3.Error as e:
            self.conn.rollback()
            messagebox.showerror("Ошибка", f"Не удалось сохранить пиццу: {e}")

